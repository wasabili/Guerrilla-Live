<html>
<head>
<title>Gloss - documentation</title>

<style>
body	{
	font-family: sans-serif;
	padding: 30px
}

h2	{
	margin-top: 30px;
	background-color: #999999;
	border: 1px solid black;
	color: white;
	padding: 5px;
}

h3	{
	margin-top: 20px;
	margin-bottom: 0;
	text-decoration: underline;
}

pre	{
	border: 1px dashed #0000ff;
	background-color: #eeeeff;
	padding: 20px;
}
</style>

</head>

<body>

<h1>Gloss documentation</h1>

<p>There are nine classes inside Gloss:</p>

<ul>
<li><a href="#Gloss">Gloss</a>: this contains lots of static methods that make your life easier, such as filling the screen with a texture and lerping.</li>
<li><a href="#GlossGame">GlossGame</a>: this is the base class for all Gloss games, and automatically calls your own methods to load content and draw the game.</li>
<li><a href="#Point">Point</a>: this holds a number of static methods useful for working with points and vectors.</li>
<li><a href="#Color">Color</a>: this stores colors as r(ed), g(reen), b(lue) and a(lpha) values, and contains methods for creating new colors as needed.</li>
<li><a href="#Texture">Texture</a>: this allows you to load images and draw them to the screen.</li>
<li><a href="#Sprite">Sprite</a>: this is a wrapper around Texture that lets you save a position and identify items uniquely.</li>
<li><a href="#SpriteFont">SpriteFont</a>: this is lets you load TrueType fonts and draw text to the screen.</li>
<li><a href="#RenderTarget">RenderTarget</a>: this lets you render a scene to a texture that can be used elsewhere.</li>
<li><a href="#ParticleSystem">ParticleSystem</a>: this lets you generate particle effects very easily.</li>
</ul>

<p><strong>Important:</strong> unless you specify otherwise, Gloss's drawing co-ordinates map directly to your screen. However, advanced users can override the drawing co-ordinates with their own by calling OpenGL directly. See example_matrixoverride.py for a working example of this.</p>

<hr noshade="noshade" />

<h2><a name="Gloss">Gloss</a></h2>
<p>This class is made up of static methods to make your game programming life easier. A static method is one that can be called without creating an object, which means you write this:</p>

<pre class="command">
Gloss.clear(Color.BLUE)
</pre>

<p>...rather than writing this:</p>

<pre class="command">
foo = Gloss()
foo.clear(Color.BLUE)
</pre>



<h3>Methods</h3>


<p><strong>bounce_both(value1, value2, amount, overshoot = 20)</strong></p>
<p>This acts like a standard interpolation call (see smooth_step(), below), except before moving it back tracks slightly as if getting a run up, and it will overshoot the target value before returning. The overshoot parameter is a percentage: the default is 20, meaning that it will backtrack 20% of the distance it has to travel, and overshoot by 20% too.</p>

<pre class="command">
val1 = 1
val2 = 3

# bounce half-way between val1 and val2, with an overshoot of 35%
val3 = Gloss.bounce_both(val1, val2, 0.5, 35)
</pre>

<p>&nbsp;</p>

<p><strong>bounce_in(value1, value2, amount, overshoot = 20)</strong></p>
<p>This acts like a standard interpolation call (see smooth_step(), below), except before moving it back tracks slightly as if getting a run up. The overshoot parameter is a percentage: the default is 20, meaning that it will backtrack 20% of the distance it has to travel.</p>

<pre class="command">
val1 = 1
val2 = 3

# bounce half-way between val1 and val2, with an overshoot of 35%
val3 = Gloss.bounce_in(val1, val2, 0.5, 35)
</pre>

<p>&nbsp;</p>

<p><strong>bounce_out(value1, value2, amount, overshoot = 20)</strong></p>
<p>This acts like a standard interpolation call (see smooth_step(), below), except it overshoots the target value before returning. The overshoot parameter is a percentage: the default is 20, meaning that it will overshoot by 20% of the distance it has to travel.</p>

<pre class="command">
val1 = 1
val2 = 3

# bounce half-way between val1 and val2, with an overshoot of 35%
val3 = Gloss.bounce_in(val1, val2, 0.5, 35)
</pre>

<p>&nbsp;</p>


<p><strong>clamp(value, minval, maxval)</strong></p>
<p>This ensures an input value "value" is equal to or greater than "minval" and equal to or less than "maxval". If it is below "minval", "minval" is returned. If it is above "maxval", "maxval" is returned. Otherwise, "value" is returned.</p>

<pre class="command">
# ensure spam is between 0 and 1
spam = 1.1
spam = Gloss.clamp(spam, 0.0, 1.0)
# spam is now 1.0
</pre>


<p>&nbsp;</p>




<p><strong>clear(color = Color.CORNFLOWER_BLUE)</strong></p>

<p>This clears the screen to a color you specify. Behind the scenes, this basically completely blanks the scene in your video card, and is very fast - much faster than using fill() and specifying your color there. However, the color will not be affected by any scene tint specified by Gloss.set_scene_tint().</p>

<p>clear() has no return value.</p>

<pre class="command">
# clear the screen solid blue
Gloss.clear(Color.BLUE)

# clear the screen to a custom color
Gloss.clear(Color(0.5, 0.25, 0.125, 1))
</pre>

<p>&nbsp;</p>



<p><strong>draw_box(position = (0, 0), width = 128, height = 128, rotation = 0.0, origin = (0, 0), scale = 1, color = Color.WHITE)</strong></p>

<p>This draws a rectangle to the screen at your choice of position, width, height and color. This is useful for a wide variety of functionality, such as creating game windows or dimming the screen while something is happening.</p>
<p>As with other drawing functionality, you can specify a rotation, origin and scale for the box that is drawn, allowing you to position it more precisely.</p>

<p>draw_box() has no return value.</p>

<pre class="command">
# draw a white square at 100x100
Gloss.draw_box((100,100))

# draw a rectangle scaled up and rotated
Gloss.draw_box(position = (300, 200), width = 500, height = 200, rotation = 45, scale = 3.0)
</pre>

<p>&nbsp;</p>



<p><strong>draw_line(start, finish, color = Color.WHITE, width = 1.0)</strong></p>

<p>The draw_line() method draws a single line on the screen, starting at point "start" and ending at point "finish". You can customise the look of the line that gets drawn by setting the color and line width.</p>

<p>draw_line() has no return value.</p>

<pre class="command">
# draw a thick, red line along the top of the screen
Gloss.draw_line((0, 0), (Gloss.screen_resolution[0], 0), Color.RED, 40.0)
</pre>

<p>&nbsp;</p>



<p><strong>draw_lines(lines, color = Color.WHITE, width = 1.0, join = False)</strong></p>

<p>Draw a series of lines as passed in through the "lines" list. As with draw_line() you can customise the look of lines drawn using draw_lines() by setting the "color" and "width" parameters. If you set "join" to be True, Gloss will draw a line from the last point back to the first point, making a continuous loop.</p>

<p>draw_lines() has no return value.</p>

<pre class="command">
# draw a square
lines = [(100,100), (100, 200), (200, 200), (200, 100)]
Gloss.draw_lines(lines, Color.WHITE, width = 10.0, join = true)
</pre>

<p>&nbsp;</p>



<p><strong>draw_triangle(points = [(0, 0), (-50, 100), (50, 100)], position = (0,0), rotation = 0.0, origin = (0, 0), scale = 1, color = Color.WHITE)</strong></p>

<p>Draw a triangle on the screen at the specific co-ordinates. Note that you need to understand exactly how this method call works before using it: you pass in the three X/Y positions of the triangle edges as a list, then give the actual position of the triangle as a separate parameter. It is imperative that you do not try to set the triangles position using the "points" parameter, as it will cause problems with rotation and scaling.</p>
<p>When specifying the triangle's points, it is useful to think of the second two co-ordinates as being relative to the first. For example:</p>


<pre class="command">
points = [(0, 0), (-50, 100), (50, 100)]
</pre>

<p>The second triangle edge is specified as being 50 pixels to the left of the first edge, and the third triangle edge is 50 pixels to the right of the first edge. It <em>doesn't</em> mean that the second edge is at X -50 on the screen, just that it's 50 pixels to the left of the first edge.</p>
<p>To set the triangle's position on the screen, use the "position" parameter. Using this method, you can define your triangle's points only once, then move it, scale it and rotate it as much as you like without having to recalculate those points each time - Gloss does all that for you.</p>
<p>As with other drawing methods, you can customise the rotation, origin, scale and color of your triangle by passing in different parameters. If you pass None as the origin, Gloss will use the centre of the triangle.</p>

<p>draw_triangle() has no return value.</p>

<pre class="command">
# draw bright red triangle
Gloss.draw_triangle(points = [(0,0), (100, 200), (-100, 200)], position = (200,200), color = Color.RED)
</pre>

<p>&nbsp;</p>



<p><strong>fill(texture = None, color = Color.WHITE, top = Color.CORNFLOWER_BLUE, bottom = Color.CORNFLOWER_BLUE, vertical = True)</strong></p>
<p>Fill the entire screen with either a texture or a color. If a render target is activated, only that render target will be filled.</p>
<p>If you want to fill the screen with a texture, you should use at least the "texture" parameter, and optionally also the color" parameter. If you specify "color", this will be used to tint the background image.</p>

<p>This method can also be used to draw gradient color backgrounds rather than textures. For example, you might want the top of the background to be light blue and the bottom to be black. In that case, use the "top" and "bottom" parameters to specify the colors of the gradient. By default, the gradient is vertical: use "vertical = False" to have the gradient move from left to right, in which case "top" specifies the left-hand color and "bottom" specifies the right-hand color.</p>

<p>fill() has no return value.</p>

<pre class="command">
# create a simple gradient fill
Gloss.fill(top = Color.WHITE, bottom = Color.BLACK)

# draw a texture stretched to fill the space
Gloss.fill(texture = sometexture)

# draw a texture tinted a shade of green
Gloss.fill(texture = sometexture, color = Color(0.5, 1.0, 0.5, 1.0))
</pre>


<p>&nbsp;</p>






<p><strong>lerp(value1, value2, amount)</strong></p>
<p>Linearly interpolate between two values ("value1" and "value2") by an amount between 0 and 1 as specified in "amount". If "amount" is 0 then value1 is returned; if "amount" is 1 then value2 is returned. For amounts between 0 and 1, this method will calculate which value between "value1" and "value2" lies at that point. For example, assume that "value1" is 0 and "value2" is 150. Specifying "amount" as 0.5 would return 75, whereas using 0.1 would return 15.</p>

<p>Linear interpolation is often used to animate sprites - for that you'll probably find the lerp() method of the Point class easier because it does X and Y at the same time.</p>

<pre class="command">
# place a texture somewhere between two positions
startpos = 100
endpos = 800
position = Gloss.lerp(startpos, endpos, 0.6)
</pre>


<p>&nbsp;</p>


<p><strong>lerp2(value1, value2, amount)</strong></p>

<p>lerp2() works similarly to lerp() with the exception that at 0.0 value1 is returned, at 0.5 value2 is returned and at 1.0 value1 is returned again, making it easier to make something move backwards and forwards.</p>

<pre class="command">
# place a texture somewhere between two positions
startpos = 10
endpos = 80
position = Gloss.lerp2(startpos, endpos, 0.6)
</pre>

<p>&nbsp;</p>



<p><strong>multi_lerp(values, amount)</strong></p>
<p>A standard linear interpolation (lerp) works between two values, where 0 is the first value, 1 is the second value, and any value inbetween is calculated. The multi_lerp() method lets you lerp between a range of values, passed in as a list. For example, you could pass in the numbers 0, 1, 2, 3 and 4 and ask Gloss to calculate the lerp of 0.5 - you'd get 2 back, because that's in the middle of the range.</p>
<p>This method is useful when you need to work with a range of possible values, and is both easier and faster than using multiple calls to lerp() yourself.</p>

<p>If you want to multi-lerp a point or a color, use the dedicated Point.multi_lerp() or Color.multi_lerp() methods.</p>

<pre class="command">
# make an alpha value flicker before fading out
lerp_pos = 0.6 # 60% of the way through
alpha = Gloss.multi_lerp([1, 0.5, 0.9, 0.4, 0.8, 0.3, 0.7, 0.2, 0.6, 0.1, 0.5, 0], lerp_pos)
</pre>


<p>&nbsp;</p>



<p><strong>rand_float(value1, value2)</strong></p>
<p>This returns a random floating-point value between "value1" and "value2", inclusive.</p>

<pre class="command">
# generate a floating-point number between 0 and 10
beans = Gloss.rand_float(0, 10)
</pre>


<p>&nbsp;</p>




<p><strong>save_screenshot(filename)</strong></p>
<p>This saves the current screen to the filename you specify.</p>

<pre class="command">
# save screenshot as mypic.png
Gloss.save_screenshot("mypic.png")
</pre>


<p>&nbsp;</p>




<p><strong>select_object(pos)</strong></p>
<p>This can be used to find out which sprite occupies a certain position on the screen. When you pass in X and Y co-ordinates as a list, select_object() will return the sprite at that location on the screen, or None if there is no sprite at that point. Note that this uses object-aligned bounding boxes for click detection, which means it will register a texture as being clicked on even if it was a transparent part of the texture that was clicked.</li>
</ol>

<pre class="command">
# check to see whether a particular texture was clicked
self.hero_texture = Texture("content/hero.png")
self.hero = Sprite(self.hero_texture, (256, 256))
self.hero.id = "Hero"

# ...later, inside an on_mouse_up event...

clicked = Gloss.select_object(event.pos)

if clicked.id == "Hero":
	# hero was clicked
</pre>

<p>If you want to track clicks for individual sprites, you will probably find it easier to use the on_click event for sprites.</p>

<p>There are two warnings for using select_object(). First, if multiple sprites occupy the same click point, this function returns the top-most sprite - the one that was drawn last. Second, calling select_object() forces Gloss to redraw your scene then read pixels back from your graphics card to see what was clicked - this can be rather slow on some computers, so if you know the position of all your objects and aren't using rotation or scaling then you should ignore select_object() and the on_click event for sprites and write your own routine.</p>

<p>&nbsp;</p>




<p><strong>set_scene_tint(color)</strong></p>
<p>This applies a coloration effect to your entire scene. For example, if you set the scene tint to be Color(0.5, 0.5, 0.5), everything will appear darker because of the grey scene tint. Setting the scene tint is a very quick and easy way to execute fades by lerping the scene tint from white to black over a couple of seconds. Note: scene tints have no effect on a background color specified using Gloss.clear().</p>

<pre class="command">
# give the whole scene an eery glow
Gloss.set_scene_tint(Color.RED)

# reset the scene tint so that everything appears normal
Gloss.set_scene_tint(Color.WHITE)
</pre>


<p>&nbsp;</p>








<p><strong>smooth_step(value1, value2, amount)</strong></p>
<p>Interpolate between two values ("value1" and "value2") by an amount between 0 and 1 as specified in "amount". If "amount" is 0 then value1 is return; if "amount" is 1 then value2 is returned. For amounts between 0 and 1, this method will calculate which value between "value1" and "value2" lies at that point. Yes, this is very similar to the lerp() method, but it has one crucial difference: whereas lerp() <em>linearly</em> interpolates between "value1" and "value2", meaning that the difference between 0.1 and 0.2 is the same as the difference between 0.2 and 0.3, smooth_step() starts off the interpolation slowly, accelerates towards the middle, then slows at the end. If you've ever used Adobe Flash, smooth_step() is equivalent to lerp() with easing in and out enabled.</p>

<p>Put simply, whereas using lerp() for movement would cause your object to move at a constant rate across the screen, using smooth_step() would make it start slow, get faster, then slow down again when "amount" approaches 1.0.</p>

<pre class="command">
# place a texture somewhere between two positions
startpos = 100
endpos = 800
position = Gloss.smooth_step(startpos, endpos, 0.6)
</pre>


<p>&nbsp;</p>

<p><strong>smooth_step2(value1, value2, amount)</strong></p>
<p>smooth_step2() works similarly to smooth_step() with the exception that at 0.0 value1 is returned, at 0.5 value2 is returned and at 1.0 value1 is returned again, making it easier to make something move backwards and forwards.</p>

<pre class="command">
# place a texture somewhere between two positions
startpos = 10
endpos = 80
position = Gloss.smooth_step(startpos, endpos, 0.6)
</pre>

<p>&nbsp;</p>



<p><strong>to_radians(degrees)</strong></p>
<p>This converts an angle in degrees into the approximate equivalent in radians, and returns it.</p>

<pre class="command">
angle = 90
radians = Gloss.to_radians(angle)
</pre>


<p>&nbsp;</p>





<h3>Helpful variables</h3>
<p>The Gloss class also contains several variables that you may find useful:</p>

<ol>
<li>"VERSION" contains the version number of the Gloss library you're using. </li>
<li>"elapsed_seconds" contains the number of seconds (usually a fraction, such as 0.016) that have elapsed since the last game update.</li>
<li>"total_seconds" contains the total number of seconds (usually a fraction, such as 130.016) that have elapsed since the game started.</li>
<li>"enable_multisampling", when set to True before run() is called, will enable 4x multisampling, giving your graphics smoother edges. Unless you want your game to work on very old hardware (or if your scenes are very busy) it is recommended to enable this feature.</li>
<li>Set "full_screen" to True before calling Run() to have your window run in full screen mode. If you didn't set up any code that quits the game using the Quit() method of the GlossGame class (you can just use self.Quit() inside your game's class) and can't find a way to exit, hold down the Control key and press Escape.</li>
<li>"joysticks" is a list containing all the joysticks that were plugged in when the game was started.</li>
<li>"running_slowly" is set to true if your game isn't being updated at 60 frames a second. If this <em>is</em> true, you should try to draw less on the screen. If that still doesn't work, you either need to optimise your code or accept that the player's computer isn't fast enough for your game.</li>
<li>"screen_resolution" lets you change the window size, but should be changed only before calling run(). For example, "Gloss.screen_resolution = 800,600" will give you an 800x600 window. If you specify 0,0 Gloss will use the player's current screen resolution.</li>
<li>"tick_count" contains the number of milliseconds that have elapsed since the game was launched.</li>
<li>You can also use "PI_OVER_2", "PI_OVER_4" and "TWO_PI" to read those commonly used values.</p>
</ol>

<p><strong>Warning: enabling multisampling may stop your game working on older computers, as less powerful GPUs do not support it.</strong></p>


<p>&nbsp;</p>


<hr noshade="noshade" />

<h2><a name="GlossGame">GlossGame</a></h2>
<p>This is the basic class that all Gloss games must inherit from. This automatically executes tedious housework for you so that you can focus on creating your game. Several of these functions are simply stubs that must be overridden by you to perform whatever actions you please - the best way to learn these is to read the tutorial or to look at some of the examples.</p>

<h3>Methods</h3>

<p><strong>__init__(name)</strong></p>
<p>This creates your new Gloss game, setting up some basic values. Note that you must provide the name of your game here.</p>
<p>&nbsp;</p>

<p><strong>draw()</strong></p>
<p>This is an empty stub method that you should override yourself to draw your scene.</p>
<p>&nbsp;</p>

<p><strong>draw_loading_screen()</strong></p>
<p>This is an empty stub method that you can override yourself if you want to show a message as soon as the game starts and before load_content() is called. Unlike the normal draw() method, draw_loading_screen() is called only once.</p>
<p>&nbsp;</p>

<p><strong>load_content()</strong></p>
<p>This is an empty stub method that you should override yourself to load all your game assets. This gets called after preload_content() and draw_loading_screen() because your game may take some time to load.</p>
<p>&nbsp;</p>

<p><strong>preload_content()</strong></p>
<p>This is an empty stub method that you can override yourself if you want to load any game data before draw_loading_screen() is called.</p>
<p>&nbsp;</p>

<p><strong>run()</strong></p>
<p>This starts the game's main loop, at which point Gloss assumes control of your game and will hand control back to you to call update(), draw() and any input handling functions you have registered.</p>
<p>&nbsp;</p>

<p><strong>update()</strong></p>
<p>This is an empty stub method that you should override yourself to update your game. Gloss automatically limits your frame rate to 60 frames per second.</p>
<p>&nbsp;</p>


<h3>Method calling order</h3>
<p>When you call run(), Gloss calls your methods in the following order:</p>

<ul>
<li>preload_content()</li>
<li>draw_loading_screen()</li>
<li>load_content()</li>
</ul>

<p>After that, update() then draw() are called repeatedly until your game finishes. The purpose of preload_content() is to load any highly important game assets that you want to use in a game loading screen (rendered using a once-off call to draw_loading_screen()) before load_content() starts. If your game is small and loads in a fraction of a second, this isn't important; but for load times greater than a couple of seconds, it is recommended that you preload some sort of "Loading..." graphic, then show it in draw_loading_screen() before continuing as normal.</p>

<p>&nbsp;</p>


<h3>Events</h3>
<p>You can attach functions to the following events in your Gloss game:</p>

<ul>
<li>on_mouse_motion: triggered whenever the mouse is moved inside your game window.</li>
<li>on_mouse_down: triggered whenever a mouse button is depressed inside your game window.</li>
<li>on_mouse_up: triggered whenever a mouse button is released inside your game window.</li>
<li>on_key_down: triggered whenever a key is depressed inside your game window.</li>
<li>on_key_up: triggered whenever a key is released inside your game window.</li>
<li>on_quit: triggered when your game terminates, allowing you to save settings and such.</li>
<li>on_joy_axis_motion, on_joy_ball_motion, on_joy_button_down, on_joy_button_up and on_joy_hat_motion: trigger whenever joystick input is received.</li>
</ul>

<p>When you create your function handlers for those events, each of them should accept one parameter: the Pygame event object that contains information about the event. You should consult the Pygame documentation for more information about this, because Gloss just passes this event straight from Pygame to you. The exception here is on_quit(), which is not from PyGame and accepts no parameters, and will be called just before your game exits, giving you time to clean up before terminating.</p>

<p>Note: if you have attached a function to the on_click event of a sprite, this function will be called after any on_mouse_up event of your game.</p>

<pre class="command">
# track mouse click position in the window caption
game = ExampleGame("Example Game")
game.on_mouse_up = handle_mouse_clicks

def handle_mouse_clicks(event):
	pygame.display.set_caption(str(event.pos[0]) + "x" + str(event.pos[1]))


# apply a sepia-tone effect when space is pressed
game.on_key_up = handle_key_presses

def handle_key_presses(event):
	if event.key is K_SPACE:
		Gloss.set_scene_tint(Color.from_bytes(210, 180, 120, 255))
</pre>


<p>&nbsp;</p>
<p>&nbsp;</p>

<hr noshade="noshade" />


<h2><a name="Point">Point</a></h2>
<p>The Point class contains a number of methods used for working with the standard two-dimensional list used for positions in both Gloss and Pygame - ie (100, 250). These "points" are most commonly used for positions, but are also used to specify origins, screen rotations and other things. They can also be used as vectors, which is a line starting at (0, 0) and ending at your point, which might sound a bit uncommon but actually using points as vectors can really improve your game!</p>

<h3>Methods</h3>
<p><strong>add(point1, point2)</strong></p>
<p>This adds point1 to point2, then returns the result as a new point.

<pre class="command">
p1 = (1,1)
p2 = (2,3)
p3 = Point.add(p1,p2) # p3 now contains (3,4)
</pre>

<p>&nbsp;</p>

<p><strong>bounce_both(point1, point2, amount, overshoot = 20)</strong></p>
<p>This acts like a standard interpolation call (see smooth_step(), below), except before moving it back tracks slightly as if getting a run up, and it will overshoot the target value before returning. The overshoot parameter is a percentage: the default is 20, meaning that it will backtrack 20% of the distance it has to travel, and overshoot by 20% too.</p>

<pre class="command">
p1 = (1,1)
p2 = (2,3)

# bounce half-way between p1 and p2, with an overshoot of 35%
p3 = Point.bounce_both(p1,p2, 0.5, 35)
</pre>

<p>&nbsp;</p>

<p><strong>bounce_in(point1, point2, amount, overshoot = 20)</strong></p>
<p>This acts like a standard interpolation call (see smooth_step(), below), except before moving it back tracks slightly as if getting a run up. The overshoot parameter is a percentage: the default is 20, meaning that it will backtrack 20% of the distance it has to travel.</p>

<pre class="command">
p1 = (1,1)
p2 = (2,3)

# bounce half-way between p1 and p2, with an overshoot of 35%
p3 = Point.bounce_in(p1,p2, 0.5, 35)
</pre>

<p>&nbsp;</p>

<p><strong>bounce_out(point1, point2, amount, overshoot = 20)</strong></p>
<p>This acts like a standard interpolation call (see smooth_step(), below), except it overshoots the target value before returning. The overshoot parameter is a percentage: the default is 20, meaning that it will overshoot by 20% of the distance it has to travel.</p>

<pre class="command">
p1 = (1,1)
p2 = (2,3)

# bounce half-way between p1 and p2, with an overshoot of 35%
p3 = Point.bounce_out(p1,p2, 0.5, 35)
</pre>

<p>&nbsp;</p>

<p><strong>distance(point1, point2)</strong></p>
<p>This returns the distance to point1 from point2, which is commonly used for circle-based collision detection and many other techniques. Note that internally distance() calls distance_squared() then square-roots the result - if you're able to use distance_squared(), you should do.</p>

<pre class="command">
def handle_mouse_clicks(self, event):
	for target in self.TargetList:
		distance = Point.distance((event.pos[0], event.pos[1]), (target.x, target.y))
 
		if (distance &lt; self.TargetRadius):
			TargetIsHit(target.HitTime)
</pre>

<p>&nbsp;</p>

<p><strong>distance_squared(point1, point2)</strong></p>
<p>This returns the distance squared to point1 from point2, which is commonly used for circle-based collision detection and many other techniques. Note that internally distance() calls distance_squared() then square-roots the result - if you're able to use distance_squared(), you should do.</p>

<pre class="command">
def handle_mouse_clicks(self, event):
	for target in self.TargetList:
		distance2 = Point.distance_squared((event.pos[0], event.pos[1]), (target.x, target.y))
 
		# this code is faster than using distance() because it avoids the square root
		if (distance2 &lt; self.TargetRadius * self.TargetRadius):
			TargetIsHit(target.HitTime)
</pre>

<p>&nbsp;</p

<p><strong>length(point)</strong></p>
<p>This returns the length of the point as if its starting point was at (0,0) and its finishing point was at "point". This is useful for measuring the total distance expressed in a point. Note that internally length() calls length_squared() then square-roots the result - if you're able to use length_squared(), you should do.</p>

<p>&nbsp;</p>

<p><strong>length_squared(point)</strong></p>
<p>This returns the length squared of the point as if its starting point was at (0,0) and its finishing point was at "point". This is useful for measuring the total distance expressed in a point, and is particularly useful when working with Pythagoras's Theorem when the source point is (0,0); if your source point is somewhere else, use distance() or distance_squared(). Note that internally length() calls length_squared() then square-roots the result - if you're able to use length_squared(), you should do.</p>
<p>&nbsp;</p>

<p><strong>lerp(point1, point2, amount)</strong></p>
<p>This linearly interpolates between two points as specified in "point1" and "point2" using "amount" as a weight parameter. See the lerp() documentation for the Gloss class for more information.</p>

<pre class="command">
p1 = (0,0)
p2 = (1,10)
p3 = Point.lerp(p1, p2, 0.6)
</pre>

<p>&nbsp;</p>


<p><strong>lerp2(point1, point2, amount)</strong></p>
<p>This linearly interpolates between two points as specified in "point1" and "point2" using "amount" as a weight parameter. However, unlike lerp(), lerp2() will return "point1" at 0.0, "point2" at 0.5, then "point1" at 1.0, allowing you to move things backwards and forwards easily. See the lerp2() documentation for the Gloss class for more information.</p>

<pre class="command">
p1 = (0,0)
p2 = (1,10)
p3 = Point.lerp(p1, p2, 0.6)
</pre>

<p>&nbsp;</p>


<p><strong>multi_lerp(values, amount)</strong></p>
<p>Linearly interpolate between a range of points passed in using the "values" list based on the weighting "amount". This method is useful if you want to make something move to various points around the screen - you just need to program in those points and you're done.</p>
<p>As with the other multi_lerp() methods, you should pass the first parameter as a "list".</p>

<pre class="command">
# make an objet move around the screen in a square shape
self.target.draw(position = Point.multi_lerp([(100, 100), (500, 100), (500, 500), (100, 500), (100, 100)], game.moveamount), origin = None)
</pre>


<p>&nbsp;</p>


<p><strong>multiply(point1, to)</strong></p>
<p>This multiplies the point in "point1" by "to", which can either be another point (in which case you have point x point multiplication) or a number (in which case you have point x number multiplication). If two points are multiplied, then the X values of the two points are multiplied and the Y values of the two points are multiplied, then the result is returned as a new point. If a point and a number are multiplied, then the X value of the point is multiplied by the number and the Y value of the point is multiplied by the number, then the result is returned as a new point.</p>

<pre class="command">
p1 = (2,2)
p2 = (1,10)
p3 = Point.multiply(p1, p2)
p4 = Point.multiply(p3, 7)
</pre>

<p>&nbsp;</p>

<p><strong>normalize(point)</strong></p>
<p>This creates and returns a unit vector from "point". If that means nothing to you, imagine that your point is a line starting at (0,0) and ended at "point". If you call normalize() with that point, it will return a line pointing in exactly the same direction, but now it will have a length of 1.</p>

<p><em>This is a very important method for game creation, but lots of people get confused by the mathematics and give up.</em> So, we're going to give you a real example: let's say your player controls a little tank. If they press Left the tank will move to the left at a speed of 10 pixels every update. If they press Up the tank will move upwards at a speed of 10 pixels every update. But what happens if they press Left and Up together? A simple solution is to have the tank move left 10 pixels and up 10 pixels every update, but that actually ends up the tank about 14 pixels diagonally - the tank actually moves faster diagonally than it could in any single direction!</p>

<p>The fix for this is to use normalize() to adjust your input before calculating speed. For example:</p>

<pre class="command">
# player wants to move down and right
input = (1,1)

# normalize the input so the player can't move more than 1 unit in any direction
input = Point.normalize(input)

# now adjust for the tank's speed
input = Point.multiply(input, self.tank_speed)
</pre>

<p>Using that method will ensure that your player moves at the same speed no matter what direction they are going in.</p>

<p>&nbsp;</p>


<p><strong>smooth_step(point1, point2, amount)</strong></p>
<p>Interpolate between two points ("point1" and "point2") by an amount between 0 and 1 as specified in "amount". If "amount" is 0 then "point1" is returned; if "amount" is 1 then "point2" is returned. For amounts between 0 and 1, this method will calculate which value between "point1" and "point2" lies at that value. See the smooth_step() method of the Gloss class for more information.</p>

<pre class="command">
p1 = (2,2)
p2 = (1,10)
p3 = Point.smooth_step(p1, p2, 0.25)
</pre>

<p>&nbsp;</p>


<p><strong>smooth_step2(point1, point2, amount)</strong></p>
<p>This is similar to smooth_step() except when "amount" is 0.0 "point1" is returned, when "amount" is 0.5 "point2" is returned, and when "amount" is 1.0 "point1" is returned again, making it easy to move something back and forwards.</p>

<pre class="command">
p1 = (1,4)
p2 = (2,3.5)
p3 = Point.smooth_step2(p1, p2, 0.69)
</pre>

<p>&nbsp;</p>


<p><strong>subtract(point1, point2)</strong></p>
<p>This subtracts "point2" from "point1" then returns the result. When subtracting points, the X component of "point2" is subtracted from the X component of "point1", then the Y component of "point2" is subtracted from the Y component of "point1".

<pre class="command">
p1 = (3,1)
p2 = (-10,15)
p3 = Point.subtract(p1, p2)
</pre>

<p>&nbsp;</p>
<p>&nbsp;</p>

<hr noshade="noshade" />

<h2><a name="Color">Color</a></h2>
<p><strong>__init__(r, g, b, a = 1.0)</strong></p>
<p>This returns a new color created from R, G, B and (optionally) A values between 0 and 1.</p>
<p>&nbsp;</p>

<p><strong>from_bytes(r, g, b, a = 255)</strong></p>
<p>This static method returns a new color created from R, G, B and (optionally) A values between 0 and 255.</p>

<pre class="command">
# create a full-red color
col = Color.from_bytes(255, 0, 0)
</pre>

<p>&nbsp;</p>



<p><strong>from_html(col)</strong></p>
<p>This static method returns a new color created from a HTML hexadecimal code, such as #ffe700.</p>

<pre class="command">
# create a full-red color
col = Color.from_html("#ff0000")
</pre>

<p>&nbsp;</p>



<p><strong>lerp(colorfrom, colorto, amount)</strong><p>
<p>Linearly interpolate between two colors ("colorfrom" and "colorto") by an amount between 0 and 1 as specified in "amount". If "amount" is 0 then colorfrom is returned; if "amount" is 1 then colorto is returned. For amounts between 0 and 1, this method will calculate which value between "colorfrom" and "colorto" lies at that point. See the lerp() method of the Gloss class for more information.</p>

<pre class="command">
# create a middle shade of grey
col = Color.lerp(Color.WHITE, Color.BLACK, 0.5)
</pre>


<p>&nbsp;</p>

<p><strong>lerp2(colorfrom, colorto, amount)</strong></p>
<p>lerp2() works similarly to lerp() with the exception that at 0.0 value1 is returned, at 0.5 value2 is returned and at 1.0 value1 is returned again, making it easier to make something move backwards and forwards.</p>

<pre class="command">
# this will return a full red color
col = Color.lerp2(Color.BLUE, Color.RED, 0.5)
</pre>

<p>&nbsp;</p>

<p><strong>multi_lerp(values, amount)</strong></p>
<p>Use multiple linear interpolation to choose between a range of values passed in as a list. A normal lerp would let you go from one color to another, but a multi-lerp lets you cycle through various colors.</p>

<pre class="command">
# make the background change color to a blue-green shade
colors = [Color.RED, Color.BLUE, Color.GREEN, Color.RED]
lerp_pos = 0.5
color = Color.multi_lerp(colors, lerp_pos)
Gloss.clear(color)
</pre>


<p>&nbsp;</p>

<p><strong>smooth_step(colorfrom, colorto, amount)</strong></p>
<p>Interpolate between two colors ("colorfrom" and "colorto") by an amount between 0 and 1 as specified in "amount". If "amount" is 0 then colorfrom is returned; if "amount" is 1 then colorto is returned. For amounts between 0 and 1, this method will calculate which value between "colorfrom" and "colorto" lies at that point. See the smooth_step() method of the Gloss class for more information.</p>

<pre class="command">
# create a middle shade of grey
col = Color.smooth_step(Color.WHITE, Color.BLACK, 0.5)
</pre>

<p>&nbsp;</p>

<p><strong>smooth_step2(colorfrom, colorto, amount)</strong></p>
<p>smooth_step2() works similarly to smooth_step() with the exception that at 0.0 value1 is returned, at 0.5 value2 is returned and at 1.0 value1 is returned again, making it easier to make something move backwards and forwards.</p>

<pre class="command">
# this will return a full red color
col = Color.smooth_step2(Color.BLUE, Color.RED, 0.5)
</pre>

<p>&nbsp;</p>

<h3>Useful variables</h3>
<p>The Color class defines a handful of basic colors for you to use: Color.WHITE, Color.RED, Color.GREEN, Color.BLUE, Color.BLACK, Color.CORNFLOWER_BLUE (the default background color for screens) and Color.PURPLE (the default background color for RenderTargets). You can also use TRANSPARENT_WHITE for a white color with zero alpha.</p>

<p>&nbsp;</p>
<p>&nbsp;</p>

<hr noshade="noshade" />


<h2><a name="Texture">Texture</a></h2>
<p>This class holds images for drawing to the screen. It is recommended only for static, non-moving items, because the Sprite class stores position and also allows picking (choosing items with the mouse).</p>

<h3>Important note about texture sizes</h3>
<p>Older graphics cards support only power of 2 textures, which means textures where the width is a power of 2 and the height is a power of 2, eg 64x64, 128x512, 1024x32, etc. To allow compatibility with older cards, Gloss will automatically convert your textures to a power of 2 size using the next highest number, eg 100x60 will produce a texture at 128x64. If your texture is already power of 2, no conversion will take place.</p>
<p>This conversion process happens transparently, without any degradation in texture quality, and your texture will be drawn at its original size on the screen. The "width", "height", "half_width" and "half_height" variables of your texture will all refer to its original size, which means you can basically pretend the conversion doesn't exist. However, it is important you are aware of this conversion because graphics cards have limits on the size of textures, and you must be aware of those limits when creating your textures.</p>
<p>For widespread compatibility, use textures with width and height less than 2048 pixels. Even after converting up to the next power of 2, this means your texture will be smaller than 2048x2048, which should work fine with most modern GPUs. For maximum compatibility, consider 1024x1024 your largest texture size.</p>

<p>&nbsp;</p>

<p><strong>__init__(source):</strong></p>
<p>Create a new texture either using a file or from a Pygame surface as specified in "source". If you have SDL_image installed, you should be able to load JPG, PNG, TGA, BMP and more. Creating from a Pygame surface is useful for when you've created a surface dynamically in Pygame and want to make use of it in Gloss.</p>



<p><strong>draw(position = (0, 0), rotation = 0.0, origin = (0, 0), scale = 1, color = Color.WHITE)</strong></p>
<p>By default you can provide no parameters to draw() to have the texture drawn in the top-left corner of the screen, which is usually what you want for backgrounds. Otherwise, you can provide a position to draw the texture. You can also specify several other parameters to adjust the way the texture is rendered, and, as always, Gloss uses smart defaults, which means that if you specify nothing other than the position then the texture will be placed so that its top-left edge is at that position and everything else will be normal.</p>

<p>You can optionally provide the following values:</p>

<ul>
<li>"rotation": this specifies the angle at which the texture should be drawn.</li>
<li>"origin": this specifies the point from which the texture should be drawn and rotated. By default this is (0, 0) meaning that the item is positioned from the top-left edge of the texture, and will be rotated as if a pin had been stuck in that corner. If you wish to rotate and position the item based upon a different point, specify it in "origin". If you pass None as "origin" Gloss will use the centre of the texture, which is usually what you want when working with rotation.</li>
<li>"scale": this lets you resize the texture smoothly. The default value is 1, which shows the texture at 100% of its original size. If you specify 0.1, it will be shown at 10% its original size. Specifying scaling values larger than 1 will stretch the texture.</li>
<li>"color": this lets you change the color of the texture in realtime. Specifying Color.WHITE (the default) will show the texture in its original colors, whereas using something like Color.RED will tint the texture red. This is very useful for changing textures to represent team colors and such.</li>
</ul>

<p>draw() has no return value.</p>


<pre class="command">
# draw a texture at the top-left corner of the screen
tex.draw()

# draw a texture at 100,100
tex.draw(position = (100, 100))

# draw a texture at 100,100 measuring from its centre
# as opposed to the top-left of the texture
tex.draw(position = (100, 100), origin = None)

# draw a texture at 100,100 measuring from its centre
# and rotate it by 135 degrees
tex.draw(position = (100, 100), rotation = 135, origin = None)
</pre>


<p>&nbsp;</p>


<h3>Helpful variables</h3>
<p>The Texture class also contains several variables that you may find useful:</p>

<ol>
<li>"width" and "height" contain the width and height of the texture</li>
<li>"half_width" and "half_height" contain the width and height of texture divided by two, which makes it easy to centre.</li>
</ol>



<p>&nbsp;</p>
<p>&nbsp;</p>

<hr noshade="noshade" />

<h2><a name="Sprite">Sprite</a></h2>
<p>This is the basic class for drawing the majority of game objects to the screen. It builds on Texture by adding a stored position and a unique identifier for every sprite, making it easy to select them.</p>


<h3>Methods</h3>
<p><strong>__init__(texture, position = None)</strong></p>
<p>This creates a new sprite using the Texture object specified in "texture". By default, the sprite is created at 0,0, but you can change that by specifying a "position" parameter. This position is stored inside the sprite so that any time you call draw() without specifying a position the sprite will be drawn at its stored position.</p>

<p>&nbsp;</p>

<p><strong>draw(position = None, rotation = 0.0, origin = (0, 0), scale = 1, color = Color.WHITE)</strong></p>
<p>When called with no parameters, draw() draws the sprite to the screen at its current location. If you want to override the sprite's current position, specify it in the "position" parameter. You can also use the following extra parameters:</p>

<ul>
<li>"rotation": this specifies the angle at which the sprite should be drawn.</li>
<li>"origin": this specifies the point from which the sprite should be drawn and rotated. By default this is (0, 0) meaning that the item is positioned from the top-left edge of its texture, and will be rotated as if a pin had been stuck in that corner. If you wish to rotate and position the item based upon a different point, specify it in "origin". If you pass None as "origin" Gloss will use the centre of the sprite's texture, which is usually what you want when working with rotation.</li>
<li>"scale": this lets you resize the sprite smoothly. The default value is 1, which shows the sprite's texture at 100% of its original size. If you specify 0.1, it will be shown at 10% its original size. Specifying scaling values larger than 1 will stretch the texture.</li>
<li>"color": this lets you change the color of the sprite in realtime. Specifying Color.WHITE (the default) will show the texture in its original colors, whereas using something like Color.RED will tint the texture red. This is very useful for changing textures to represent team colors and such.</li>
</ul>

<pre class="command">
# draw a simple sprite at its current position
spt_gem.draw()

# draw a sprite scaled to 250% and recolored
spt_gem.draw(scale = 2.5, color = Color.RED)
</pre>


<p>&nbsp;</p>

<p><strong>move(x, y)</strong></p>
<p>This moves a sprite relative to its current position.</p>

<pre class="command">
# move a sprite 100 pixels to the left
spt_gem.move(-100,0)
</pre>

<p>&nbsp;</p>

<p><strong>move_to(x, y)</strong></p>
<p>This moves a sprite to an exact position on the screen. If either "x" or "y" are None, the sprite's existing position for that co-ordinate will be used</p>

<pre class="command">
# move a sprite to (300,400) pixels to the left
spt_gem.move_to(300,400)

# move a sprite so that it's 300 pixels from the left of the screen's edge,
# but don't change its Y position
spt_gem.move_to(300, None)
</pre>

<p>&nbsp;</p>

<h3>Events</h3>
<p>You can attach a function to the on_click event of a sprite and it will be called whenever that sprite is clicked, passing in the sprite as a parameter. This allows you to attach the same function to multiple sprites, differentiating between the sprites inside the function.</p>

<pre class="command">
class ExampleGame(GlossGame):
	def load_content(self):
		self.tex_balloon = Texture("content/balloon_black.png");

		self.balloon1 = Sprite(self.tex_balloon)
		self.balloon2 = Sprite(self.tex_balloon)
		self.balloon3 = Sprite(self.tex_balloon)

		self.balloon1.on_click = self.clicky
		self.balloon2.on_click = self.clicky
		self.balloon3.on_click = self.clicky

	def clicky(self, sprite):
		print("Clicked sprite " + sprite.id)
</pre>

<p>This on_click event is triggered whenever the sprite is clicked on, which means that if one sprite is drawn on top of another, it is the top-most sprite that will have its on_click event triggered. That is, if you have two sprites sitting in the same space, both with on_click functions attached, only the top-most sprite (the one that was drawn last) will have its function called.</p>

<p>As with select_object, using on_click events forces Gloss to redraw your scene then read pixels back from your graphics card to see what was clicked - this can be rather slow on some computers, so if you know the position of all your objects and aren't using rotation or scaling then you should ignore select_object() and the on_click event for sprites and write your own routine.</p>

<p>&nbsp;</p>

<h3>Helpful variables</h3>
<p>The Sprite class also contains several variables that you may find useful:</p>

<ol>
<li>"texture" contains the Texture object being used by this sprite.</li>
<li>"position" contains the position of the sprite.</li>
<li>"id" is the unique identifier for this sprite. This is assigned automatically as a number, but you can change it to something specific if you want to make calls to Gloss.select_object() easier.</li>
</ol>

<p>&nbsp;</p>
<p>&nbsp;</p>

<hr noshade="noshade" />

<h2><a name="SpriteFont">SpriteFont</a></h2>
<p>This class lets you load TrueType fonts into your game, then render them to the screen at a point size of your choosing. As with other drawable objects, you can spin, rotate, scale and color fonts on the fly.</p>


<h3>Methods</h3>
<p><strong>__init__(self, filename, size = 18, bold = False, underline = False, startcharacter = 32, endcharacter = 126)</strong></p>
<p>This creates a new font object using the font file specified in "filename". You can also optionally specify a size for the font in points, along with whether you wish to have the font bold or underlined. Behind the scenes this builds upon Pygame's font rendering code, so the same proviso stands: it's better to find a real bold font than force a fake bold by setting "bold" to be True here.</p>

<p>Although you can scale text on the fly, this is not the same as specifying a different point size when creating a font. If you create a 10-point font and scale it up to 400% its size, it will look much blurrier than a 40-point font drawn at 100% its size, so make sure you choose the right size.</p>

<p>By default, all characters between ASCII 32 (a space) and ASCII 126 (a tilde, "~") are created as textures. If you want to maximise performance and require only a limited subset of characters (eg only uppercase letters, or only numbers), set "startcharacter" and "endcharacter" accordingly. See <a href="http://www.asciitable.com">www.asciitable.com</a> for a list of ASCII characters.</p>

<p>&nbsp;</p>

<p><strong>draw(self, text = "Hello, Gloss!", position = (0, 0), rotation = 0.0, scale = 1.0, color = Color.WHITE, letterspacing = 0, linespacing = 0)</strong></p>
<p>Once you have created your font, you can draw text with it by calling its draw() method. Calling draw() with no parameters will write "Hello, Gloss!" in white in the top-left corner, but you can customise that by changing its parameters:</p>

<ul>
<li>"text" changes the text you want to write. If you include line breaks using the newline character ("\n"), these will start new lines in your text.</li>
<li>"position" is a tuple containing the X,Y co-ordinates to draw from.</li>
<li>"rotation" is an angle in degrees specifying how much to rotate the text.</li>
<li>"scale" allows you to shrink the text by specifying a value lower than 1, or the stretch the text by specifying a value greater than 1.</li>
<li>"color" lets you choose a color for the text, and defaults to plain white.</li>
<li>"letterspacing" lets you modify the distance between letters. Specifying a negative value here will pull letters together by that number of pixels, whereas specifying a positive value will add more space between letters.</li>
<li>"linespacing" lets you modify the distance between lines. Specifying a negative value here will pull lines together by that number of pixels, whereas specifying a positive value will add more space between lines.</li>
</ul>

<p>Note: both "letterspacing" and "linespacing" are specified in pixels if "scale" is set to 1.0. That is, if you specify "letterspacing" to be -4 and "scale" to 0.5, "letterspacing" will be scaled as well as the text, modifying the spacing between letters by -2 rather than -4.</p>

<p>&nbsp;</p>
<p>&nbsp;</p>

<hr noshade="noshade" />

<h2><a name="RenderTarget">RenderTarget</a></h2>
<p>This class makes it easy to use a technique called "render to texture". For example, if you want to render some textures to your screen, then take that whole screen and use it as a texture somewhere else, render targets are for you. That said, some people find them hard to understand, so you should check the tutorial to learn how to use them.</p>
<p><strong>Warning: render targets are more GPU intensive than other Gloss operations, and may not be supported on older or less powerful graphics cards.</strong></p>

<h3>Methods</h3>

<p><strong>__init__(width = 512, height = 512)</strong></p>
<p>This creates a new RenderTarget with a width and height you specify. The width and height you specify here affects the size of the texture that is created, but you can change the size this texture is drawn to the screen in the draw() method.</p>

<p>&nbsp;</p>



<p><strong>activate()</strong></p>
<p>This activates the RenderTarget for drawing, which means that every drawing operation takes place inside this RenderTarget under deactivate() is called.</p>

<p>activate() has no return value.</p>

<p>&nbsp;</p>




<p><strong>deactivate()</strong></p>
<p>This deactivates the RenderTarget for drawing, which means that any future drawing operations take place on the main screen.</p>
	
<p>deactivate() has no return value.</p>

<p>&nbsp;</p>



<p><strong>draw(position, width = None, height = None, rotation = 0.0, origin = (0, 0), scale = 1, color = Color.WHITE)</strong><p>
<p>This draws the contents of a RenderTarget to the screen at the position specified in "position". By default the RenderTarget is drawn at full size with no rotation, but you can optionally specify some or all of the following parameters to change the way it's drawn:</p>

<ul>
<li>"width" and "height" are set to "None" by default, which will draw the RenderTarget at full size. If you want to specify a particular size, do so here.</li>
<li>"rotation" allows you to specify a value, in degrees, that should be used to rotate the RenderTarget's texture.</li>
<li>"origin" lets you specify the origin for position and rotation (see the draw() method of the Texture class for more information). Specify None to use the centre of the RenderTarget.</li>
<li>"scale" lets you draw the RenderTarget bigger or smaller. The default value is 1, meaning that it is drawn at 100% size; specifying 0.1 will draw it at 10% size. Note that scaling is applied after width and height, so if you specify width and height 500 and scaling 0.1, the width and height will be scaled down to 50.</li>
<li>"color" lets you tint the RenderTarget's texture to a color of your choosing. Specifying Color.WHITE will show the RenderTarget's texture in its original form, whereas using Color.BLUE will tint it blue.</li>
</ul>

<p>draw() has no return value.</p>

<pre class="command">
# draw the contents of a render target, scaled up to 3x its size
rt.draw(position = (200, 200), scale = 3)
</pre>


<p>&nbsp;</p>



<p>&nbsp;</p>

<hr noshade="noshade" />

<h2><a name="ParticleSystem">ParticleSystem</a></h2>
<p>This class makes it easy to do special effects such as smoke, fire and explosions. As with many features of Gloss, smart defaults are used so that you can change only the bits you want, keeping your code nice and clean.</p>

<p>Getting particle systems to look just right takes a little tinkering, but once you get the hang of it you'll find you can create all sorts of special effects using them - fire, smoke, water, explosions, sparkles, space dust and more can all be done very easily.</p>


<h3>Methods</h3>

<p><strong>__init__(texture, position = None, lifespan = -1, creationspeed = None, initialparticles = 50, particlelifespan = 1000, minspeed = 50, maxspeed = 250, minrotation = 0, maxrotation = 0, minscale = 1.0, maxscale = 1.0, growth = 0.0, wind = None, drag = 0, startcolor = Color(1, 1, 1, 1), endcolor = Color(0, 0, 0, 0))</strong></p>
<p>This creates a new particle system, and you're probably thinking it's really hard to use. But thanks to all those default parameters, all you need to specify is the texture you want to use for your particles and you're done. After that, you will probably want to specify the position, along with some of these:</p>

<ul>
<li>"lifespan": this sets the lifespan, in milliseconds, of the entire particle system. If this value has been exceeded and there are no more particles, the particle system will be destroyed. Set this to -1 to have the particle system run continuously.</li>
<li>"creationspeed": this defines how fast in milliseconds new particles should be created. The default value is None, which means no new particles will be created.</li>
<li>"initialparticles": this creates a number of particles at the beginning of your particle system's life. This is most useful for effects like fireworks or explosions, where many (and sometimes all) the particles need to be created at the beginning of the effect.</li>
<li>"particlelifespan": this stores a value in milliseconds of how long each particle should live.</li>
<li>"minspeed" and "maxspeed" set the minimum and maximum speed of a particle moving outwards from the centre of the particle system.</li>
<li>"minrotation" and "maxrotation" set the minimum and maximum rotation values in degrees that a particle may be created with. By default these values are both 0, meaning that all particles will be at their natural orientation of the texture.</li>
<li>"minscale" and "maxscale" are used to define how big each particle should be when created. By default these values are both 1.0, meaning that all particles are created at the natural size of the texture. If you want particles to be appear between 10% and 200% of their original size, for example, set "minscale" to 0.1 and "maxscale" to 2.0.</li>
<li>"growth" defines whether particles should get larger over time or whether they should get smaller. For effects such as fire and smoke, where the particles should appear to dissipate over time, setting "growth" to 1.0 will cause the particles to increase their size by 100% over their lifespan. If you want particles to shrink until they disappear, use -1.0.</li>
<li>"wind" allows particles to drift in a particular direction over time. This must be specified as a tuple defining the direction of the wind. For example, (1, 0) is wind with a strength of 1 unit to the right, causing particles to float to the right naturally.</li>
<li>"drag" lets you apply friction to the movement of each particle, causing it to slow down (or, if you specify a negative number, accelerate!) over time.</li>
<li>"startcolor" and "endcolor" allow you to tint particles with a color of your choosing. If you specify Color.WHITE the particle texture will be shown with its original colors. Gloss automatically lerps between the start and end color over the particle's lifespan, so a common technique is to use the same "endcolor" as for the "startcolor" with the exception that the alpha of "endcolor" is 0 so that it fades away as the particles gets older.</li>
</ul>

<pre class="command">
# create a simple particle system
particles = ParticleSystem(firetexture, position = (320, 320))

# create a particle system with drag and east-south-east wind
particles = ParticleSystem(firetexture, position = (320, 320), drag = 3, wind = (1, 0.5))
</pre>



<p>&nbsp;</p>

<p><strong>draw()</strong></p>
<p>Draw the particle system to the screen.</p>

<p>draw() has no return value.</p>



<h3>Helpful variables</h3>

<ul>
<li>"position" lets you move the particle system to a new place on the screen. Note: this will not affect any particles that have already been created.</li>

<li>"frozen", when set to True, will stop the particle system from being updated automatically by Gloss.</li>

<li>"alive" is automatically set to False for particle systems that have expired, either by reaching their lifespan or by doing nothing for too long.</li>

<li>"additive", when set to True, will used additive blending to draw the particles. This makes overlapping particles appear brighter, which is perfect for explosions and other special effects.</li>

</ul>

</body>

</html>
